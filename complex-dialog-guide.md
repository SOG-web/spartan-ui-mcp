# This was generated by Cursor. using the spartan-ui-mcp server.

# Building a Reusable Complex Dialog Component with Spartan UI

This guide demonstrates how to build a sophisticated, reusable dialog component using the Spartan UI MCP server documentation and best practices.

## Overview

Spartan UI provides a powerful dialog system with two APIs:

- **Brain API (`@spartan-ng/brain/dialog`)**: Handles behavior, accessibility, and logic
- **Helm API (`@spartan-ng/helm/dialog`)**: Provides pre-styled components with Tailwind CSS

## Architecture

Our complex dialog component will support:

- Multiple dialog types (confirmation, form, custom content)
- Dynamic content injection
- Type-safe configuration
- Consistent styling and behavior
- Accessibility features
- Declarative and imperative usage

## Implementation

### 1. Core Interfaces and Types

First, let's define the TypeScript interfaces for our dialog system:

```typescript
// dialog.types.ts
export interface DialogConfig<T = any> {
  title?: string;
  description?: string;
  type?: "confirmation" | "form" | "custom";
  size?: "sm" | "md" | "lg" | "xl";
  showCloseButton?: boolean;
  closable?: boolean;
  data?: T;
  contentClass?: string;
  overlayClass?: string;
}

export interface ConfirmationDialogData {
  message: string;
  confirmText?: string;
  cancelText?: string;
  variant?: "default" | "destructive";
}

export interface FormDialogData<T = any> {
  fields: FormField[];
  submitText?: string;
  cancelText?: string;
  initialData?: T;
}

export interface FormField {
  key: string;
  label: string;
  type:
    | "text"
    | "email"
    | "password"
    | "number"
    | "textarea"
    | "select"
    | "checkbox";
  required?: boolean;
  placeholder?: string;
  options?: Array<{ label: string; value: any }>;
  validation?: (value: any) => string | null;
}

export interface DialogResult<T = any> {
  action: "confirm" | "cancel" | "submit" | "close";
  data?: T;
}
```

### 2. Base Dialog Service

Create a service to manage dialog instances and provide type-safe methods:

```typescript
// dialog.service.ts
import { Injectable, inject, ComponentRef } from "@angular/core";
import { Observable } from "rxjs";
import { HlmDialogService, BrnDialogRef } from "@spartan-ng/helm/dialog";
import { ComplexDialogComponent } from "./complex-dialog.component";
import { DialogConfig, DialogResult } from "./dialog.types";

@Injectable({
  providedIn: "root",
})
export class ComplexDialogService {
  private readonly _hlmDialogService = inject(HlmDialogService);

  /**
   * Opens a confirmation dialog
   */
  openConfirmation(
    config: DialogConfig<ConfirmationDialogData>
  ): Observable<DialogResult> {
    return this._openDialog({
      ...config,
      type: "confirmation",
    });
  }

  /**
   * Opens a form dialog
   */
  openForm<T = any>(
    config: DialogConfig<FormDialogData<T>>
  ): Observable<DialogResult<T>> {
    return this._openDialog({
      ...config,
      type: "form",
    });
  }

  /**
   * Opens a custom dialog with dynamic content
   */
  openCustom<T = any>(
    component: any,
    config: DialogConfig<T>
  ): Observable<DialogResult<T>> {
    const dialogRef = this._hlmDialogService.open(component, {
      context: config.data,
      contentClass: this._getContentClass(config),
      hasBackdrop: true,
      closeOnBackdropClick: config.closable !== false,
      disableClose: config.closable === false,
    });

    return dialogRef.closed$;
  }

  private _openDialog<T = any>(
    config: DialogConfig<T>
  ): Observable<DialogResult<T>> {
    const dialogRef = this._hlmDialogService.open(ComplexDialogComponent, {
      context: config,
      contentClass: this._getContentClass(config),
      hasBackdrop: true,
      closeOnBackdropClick: config.closable !== false,
      disableClose: config.closable === false,
    });

    return dialogRef.closed$;
  }

  private _getContentClass(config: DialogConfig): string {
    const sizeClasses = {
      sm: "sm:max-w-[425px]",
      md: "sm:max-w-[500px]",
      lg: "sm:max-w-[700px]",
      xl: "sm:max-w-[900px]",
    };

    const sizeClass = sizeClasses[config.size || "md"];
    return `${sizeClass} ${config.contentClass || ""}`.trim();
  }
}
```

### 3. Complex Dialog Component

The main dialog component that handles different dialog types:

```typescript
// complex-dialog.component.ts
import { Component, inject, OnInit, signal } from "@angular/core";
import {
  FormBuilder,
  FormGroup,
  ReactiveFormsModule,
  Validators,
} from "@angular/forms";
import { CommonModule } from "@angular/common";

import { BrnDialogRef, injectBrnDialogContext } from "@spartan-ng/brain/dialog";
import {
  HlmDialogContent,
  HlmDialogDescription,
  HlmDialogFooter,
  HlmDialogHeader,
  HlmDialogTitle,
} from "@spartan-ng/helm/dialog";
import { HlmButton } from "@spartan-ng/helm/button";
import { HlmInput } from "@spartan-ng/helm/input";
import { HlmLabel } from "@spartan-ng/helm/label";
import { HlmTextarea } from "@spartan-ng/helm/textarea";
import { HlmSelect } from "@spartan-ng/helm/select";
import { HlmCheckbox } from "@spartan-ng/helm/checkbox";

import { DialogConfig, DialogResult, FormField } from "./dialog.types";

@Component({
  selector: "app-complex-dialog",
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    HlmDialogContent,
    HlmDialogHeader,
    HlmDialogTitle,
    HlmDialogDescription,
    HlmDialogFooter,
    HlmButton,
    HlmInput,
    HlmLabel,
    HlmTextarea,
    HlmSelect,
    HlmCheckbox,
  ],
  template: `
    <div class="flex flex-col gap-4">
      <!-- Header -->
      <hlm-dialog-header>
        <h3 hlmDialogTitle>{{ config.title }}</h3>
        <p hlmDialogDescription *ngIf="config.description">
          {{ config.description }}
        </p>
      </hlm-dialog-header>

      <!-- Content -->
      <div class="flex-1">
        <!-- Confirmation Dialog -->
        <div *ngIf="config.type === 'confirmation'" class="py-4">
          <p>{{ config.data?.message }}</p>
        </div>

        <!-- Form Dialog -->
        <div *ngIf="config.type === 'form' && formGroup" class="space-y-4 py-4">
          <form [formGroup]="formGroup" class="space-y-4">
            <div *ngFor="let field of config.data?.fields" class="space-y-2">
              <label hlmLabel [for]="field.key">
                {{ field.label }}
                <span *ngIf="field.required" class="text-red-500">*</span>
              </label>

              <!-- Text/Email/Password/Number Input -->
              <input
                *ngIf="
                  ['text', 'email', 'password', 'number'].includes(field.type)
                "
                hlmInput
                [id]="field.key"
                [type]="field.type"
                [placeholder]="field.placeholder"
                [formControlName]="field.key"
              />

              <!-- Textarea -->
              <textarea
                *ngIf="field.type === 'textarea'"
                hlmTextarea
                [id]="field.key"
                [placeholder]="field.placeholder"
                [formControlName]="field.key"
                rows="3"
              ></textarea>

              <!-- Select -->
              <select
                *ngIf="field.type === 'select'"
                hlmSelect
                [id]="field.key"
                [formControlName]="field.key"
              >
                <option value="" disabled>
                  Select {{ field.label.toLowerCase() }}
                </option>
                <option
                  *ngFor="let option of field.options"
                  [value]="option.value"
                >
                  {{ option.label }}
                </option>
              </select>

              <!-- Checkbox -->
              <div
                *ngIf="field.type === 'checkbox'"
                class="flex items-center space-x-2"
              >
                <input
                  hlmCheckbox
                  [id]="field.key"
                  [formControlName]="field.key"
                  type="checkbox"
                />
                <label hlmLabel [for]="field.key">{{ field.label }}</label>
              </div>

              <!-- Validation Error -->
              <div
                *ngIf="
                  formGroup.get(field.key)?.invalid &&
                  formGroup.get(field.key)?.touched
                "
                class="text-sm text-red-500"
              >
                {{ getFieldError(field) }}
              </div>
            </div>
          </form>
        </div>

        <!-- Custom Dialog -->
        <div *ngIf="config.type === 'custom'" class="py-4">
          <ng-content></ng-content>
        </div>
      </div>

      <!-- Footer -->
      <hlm-dialog-footer>
        <div class="flex gap-2 justify-end">
          <!-- Cancel/Close Button -->
          <button
            *ngIf="config.closable !== false"
            hlmBtn
            variant="outline"
            (click)="onCancel()"
          >
            {{ getCancelText() }}
          </button>

          <!-- Confirm/Submit Button -->
          <button
            hlmBtn
            [variant]="getConfirmVariant()"
            [disabled]="isSubmitDisabled()"
            (click)="onConfirm()"
          >
            {{ getConfirmText() }}
          </button>
        </div>
      </hlm-dialog-footer>
    </div>
  `,
  host: {
    class: "block",
  },
})
export class ComplexDialogComponent implements OnInit {
  private readonly _dialogRef =
    inject<BrnDialogRef<DialogResult>>(BrnDialogRef);
  private readonly _fb = inject(FormBuilder);

  protected readonly config = injectBrnDialogContext<DialogConfig>();
  protected formGroup: FormGroup | null = null;
  protected readonly loading = signal(false);

  ngOnInit() {
    if (this.config.type === "form" && this.config.data?.fields) {
      this.initializeForm();
    }
  }

  private initializeForm() {
    const formControls: { [key: string]: any } = {};

    this.config.data.fields.forEach((field: FormField) => {
      const validators = [];
      if (field.required) {
        validators.push(Validators.required);
      }

      // Add field-specific validators
      if (field.type === "email") {
        validators.push(Validators.email);
      }

      const initialValue =
        this.config.data.initialData?.[field.key] ||
        (field.type === "checkbox" ? false : "");

      formControls[field.key] = [initialValue, validators];
    });

    this.formGroup = this._fb.group(formControls);
  }

  protected onCancel() {
    this._dialogRef.close({
      action: "cancel",
    });
  }

  protected onConfirm() {
    if (this.config.type === "confirmation") {
      this._dialogRef.close({
        action: "confirm",
      });
    } else if (this.config.type === "form") {
      this.onSubmitForm();
    }
  }

  private onSubmitForm() {
    if (!this.formGroup?.valid) {
      this.formGroup?.markAllAsTouched();
      return;
    }

    this.loading.set(true);

    // Simulate async operation
    setTimeout(() => {
      this._dialogRef.close({
        action: "submit",
        data: this.formGroup?.value,
      });
    }, 500);
  }

  protected isSubmitDisabled(): boolean {
    if (this.loading()) return true;
    if (this.config.type === "form") {
      return !this.formGroup?.valid;
    }
    return false;
  }

  protected getCancelText(): string {
    if (this.config.type === "confirmation") {
      return this.config.data?.cancelText || "Cancel";
    }
    if (this.config.type === "form") {
      return this.config.data?.cancelText || "Cancel";
    }
    return "Close";
  }

  protected getConfirmText(): string {
    if (this.config.type === "confirmation") {
      return this.config.data?.confirmText || "Confirm";
    }
    if (this.config.type === "form") {
      return this.config.data?.submitText || "Submit";
    }
    return "OK";
  }

  protected getConfirmVariant(): string {
    if (
      this.config.type === "confirmation" &&
      this.config.data?.variant === "destructive"
    ) {
      return "destructive";
    }
    return "default";
  }

  protected getFieldError(field: FormField): string {
    const control = this.formGroup?.get(field.key);
    if (!control?.errors) return "";

    if (control.errors["required"]) {
      return `${field.label} is required`;
    }
    if (control.errors["email"]) {
      return "Please enter a valid email address";
    }

    // Custom validation
    if (field.validation && control.value) {
      const customError = field.validation(control.value);
      if (customError) return customError;
    }

    return "Invalid value";
  }
}
```

### 4. Usage Examples

Here are comprehensive examples showing how to use the complex dialog system:

```typescript
// app.component.ts
import { Component, inject } from "@angular/core";
import { ComplexDialogService } from "./complex-dialog.service";

@Component({
  selector: "app-root",
  template: `
    <div class="p-8 space-y-4">
      <h1 class="text-2xl font-bold">Complex Dialog Examples</h1>

      <div class="space-x-4">
        <button hlmBtn (click)="openConfirmationDialog()">
          Confirmation Dialog
        </button>

        <button hlmBtn (click)="openFormDialog()">Form Dialog</button>

        <button hlmBtn (click)="openDestructiveDialog()">
          Destructive Dialog
        </button>

        <button hlmBtn (click)="openUserFormDialog()">User Form Dialog</button>
      </div>

      <div *ngIf="lastResult" class="mt-4 p-4 bg-gray-100 rounded">
        <h3 class="font-semibold">Last Dialog Result:</h3>
        <pre>{{ lastResult | json }}</pre>
      </div>
    </div>
  `,
})
export class AppComponent {
  private readonly _dialogService = inject(ComplexDialogService);

  lastResult: any = null;

  openConfirmationDialog() {
    this._dialogService
      .openConfirmation({
        title: "Delete Item",
        description: "Are you sure you want to delete this item?",
        data: {
          message:
            "This action cannot be undone. The item will be permanently deleted.",
          confirmText: "Delete",
          cancelText: "Cancel",
        },
        size: "sm",
      })
      .subscribe((result) => {
        this.lastResult = result;
      });
  }

  openFormDialog() {
    this._dialogService
      .openForm({
        title: "Contact Form",
        description: "Please fill out the form below",
        data: {
          fields: [
            {
              key: "name",
              label: "Full Name",
              type: "text",
              required: true,
              placeholder: "Enter your full name",
            },
            {
              key: "email",
              label: "Email",
              type: "email",
              required: true,
              placeholder: "Enter your email",
            },
            {
              key: "message",
              label: "Message",
              type: "textarea",
              required: true,
              placeholder: "Enter your message",
            },
            {
              key: "newsletter",
              label: "Subscribe to newsletter",
              type: "checkbox",
            },
          ],
          submitText: "Send Message",
          cancelText: "Cancel",
        },
        size: "lg",
      })
      .subscribe((result) => {
        this.lastResult = result;
      });
  }

  openDestructiveDialog() {
    this._dialogService
      .openConfirmation({
        title: "Danger Zone",
        description: "This action is irreversible",
        data: {
          message:
            "This will permanently delete your account and all associated data.",
          confirmText: "Delete Account",
          cancelText: "Keep Account",
          variant: "destructive",
        },
        size: "md",
      })
      .subscribe((result) => {
        this.lastResult = result;
      });
  }

  openUserFormDialog() {
    this._dialogService
      .openForm({
        title: "User Profile",
        data: {
          fields: [
            {
              key: "username",
              label: "Username",
              type: "text",
              required: true,
              validation: (value) => {
                if (value.length < 3)
                  return "Username must be at least 3 characters";
                if (!/^[a-zA-Z0-9_]+$/.test(value))
                  return "Username can only contain letters, numbers, and underscores";
                return null;
              },
            },
            {
              key: "role",
              label: "Role",
              type: "select",
              required: true,
              options: [
                { label: "Admin", value: "admin" },
                { label: "User", value: "user" },
                { label: "Guest", value: "guest" },
              ],
            },
            {
              key: "age",
              label: "Age",
              type: "number",
              required: false,
            },
          ],
          initialData: {
            username: "john_doe",
            role: "user",
            age: 25,
          },
        },
        size: "md",
      })
      .subscribe((result) => {
        this.lastResult = result;
      });
  }
}
```

## Installation and Setup

1. **Install Spartan UI CLI:**

   ```bash
   npm i -D @spartan-ng/cli
   ```

2. **Install required dependencies:**

   ```bash
   npm i @angular/cdk
   ```

3. **Setup Tailwind with Spartan preset:**

   ```javascript
   // tailwind.config.js
   module.exports = {
     presets: [require("@spartan-ng/brain/hlm-tailwind-preset")],
     content: ["./src/**/*.{html,ts}"],
     // ... rest of config
   };
   ```

4. **Add CSS variables to styles.css:**

   ```bash
   ng g @spartan-ng/cli:ui-theme
   ```

5. **Install dialog component:**
   ```bash
   ng g @spartan-ng/cli:ui dialog
   ```

## Key Features

✅ **Type Safety**: Full TypeScript support with interfaces and generics  
✅ **Accessibility**: Built on Angular CDK with ARIA support  
✅ **Customizable**: Flexible configuration options  
✅ **Validation**: Built-in and custom form validation  
✅ **Responsive**: Tailwind CSS responsive design  
✅ **Reusable**: Single service handles multiple dialog types  
✅ **Observable-based**: RxJS integration for async operations

## Best Practices

1. **Always use the service**: Don't instantiate dialogs directly
2. **Handle subscriptions**: Unsubscribe from dialog results to prevent memory leaks
3. **Validate inputs**: Use both client-side and server-side validation
4. **Consider UX**: Use appropriate dialog sizes and clear messaging
5. **Test accessibility**: Ensure keyboard navigation and screen reader support
6. **Error handling**: Provide clear error messages and fallbacks

This implementation provides a robust, type-safe, and highly customizable dialog system that leverages the full power of Spartan UI while maintaining excellent developer experience and user accessibility.
